
\documentclass[10pt,english, openany]{book}
\usepackage[]{graphicx}
\usepackage[]{color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\usepackage{alltt}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\setlength{\parskip}{\smallskipamount}
\setlength{\parindent}{0pt}

% Set page margins
\usepackage[top=100pt,bottom=100pt,left=100pt,right=100pt]{geometry}

% Package used for placeholder text
\usepackage{lipsum}

% Prevents LaTeX from filling out a page to the bottom
\raggedbottom

% Adding both languages
\usepackage[english]{babel}

% All page numbers positioned at the bottom of the page
\usepackage{fancyhdr}
\fancyhf{} % clear all header and footers
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0pt} % remove the header rule
\pagestyle{fancy}

% Changes the style of chapter headings
\usepackage{titlesec}
\titleformat{\chapter}
   {\normalfont\LARGE\bfseries}{\thechapter.}{1em}{}
% Change distance between chapter header and text
\titlespacing{\chapter}{0pt}{50pt}{2\baselineskip}

% Adds table captions above the table per default
\usepackage{float}
\floatstyle{plaintop}
\restylefloat{table}

% Adds space between caption and table
\usepackage[tableposition=top]{caption}

% Adds hyperlinks to references and ToC
\usepackage{hyperref}
\hypersetup{hidelinks,linkcolor = black} % Changes the link color to black and hides the hideous red border that usually is created

% If multiple images are to be added, a folder (path) with all the images can be added here 
\graphicspath{ {Figures/} }

% Separates the first part of the report/thesis in Roman numerals
\frontmatter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Starts the document
\begin{document}

%%% Selects the language to be used for the first couple of pages
\selectlanguage{english}

%%%%% Adds the title page
\begin{titlepage}
	\clearpage\thispagestyle{empty}
	\centering
	\vspace{1cm}

	% Titles
	% Information about the University
	{\normalsize School of Computer Science and Technology \\ 
	Zhejiang University \par}
		\vspace{3cm}
	{\Huge \textbf{Skip List}} \\
	%\vspace{1cm}
	%{\large \textbf{xxxxx} \par}
	\vspace{4cm}
	{\normalsize FIRST LAST \\ % \\ specifies a new line
	             FIRST LAST \\
	             FIRST LAST\par}
	\vspace{5cm}
    
    \centering \includegraphics[scale=0.4]{logo1.pdf}
    
    \vspace{0.5cm}
		
	% Set the date
	{\normalsize 2020-05-20 \par}
	
	\pagebreak

\end{titlepage}

% Adds a table of contents
\tableofcontents{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Text body starts here!
\mainmatter

\chapter{Introduction}
\textit{Skip list} is a data structure that allows $\mathcal O(\log n)$ search complexity as well as $\mathcal O(\log n)$ insertion complexity within an ordered sequence of $n$ elements. Thus it can get the best features of an array while maintaining a linked list-like structure that allows insertion, which is not possible in an array. 

Fast search is made possible by maintaining a linked hierarchy of subsequences, with each successive subsequence skipping over fewer elements than the previous one. 

Searching starts in the sparsest subsequence until two consecutive elements have been found, one smaller and one larger than or equal to the element searched for. Via the linked hierarchy, these two elements link to elements of the next sparsest subsequence, where searching is continued until finally we are searching in the full sequence.
\vspace{2cm}
\begin{figure}[h]
	\centering
	\includegraphics[scale = 0.4]{Figures/Linked_Lists}
	\caption{Linked Lists with Additional Pointers}
\end{figure}
\chapter{Algorithm Specification}
\section{Data Structures}
\subsection{\texttt{class Node}}
\subsection{\texttt{class SkipList}}
\section{Main Operations}
\subsection{Search}
We search for an element by traversing forward pointers that do not overshoot the node containing the element being searched for. When no more progress can be made at the current level of forward pointers, the search moves down to the next level. When we can make no more progress at level 1, we must be immediately in front of the node that contains the desired element(it it is in the list).
\begin{algorithm}
\caption{Search(list, searchKey)}	
\begin{algorithmic}[1]
	 \Require Slip list, search key
	 \Ensure required value
	 \State x:=list$\rightarrow$header
	 \State --loop invariant: x$\rightarrow$key
	 \For {i:=list$\rightarrow$level \textbf{downto} 1}
	 \While {x$\rightarrow$forward[i]$\rightarrow$key $<$ searchKey}
	 \State i:=list$\rightarrow$forward[i]
	 \EndWhile
	 \EndFor
	 \State x:=x$\rightarrow$forward[1]
	 \If {x$\rightarrow$key = searchKey} 
	 \State \Return {x$\rightarrow$value} 
	 \EndIf
	 \State \Return \textit{failure}
\end{algorithmic}
\end{algorithm}

\subsection{Insert}
\subsubsection{Generate Random Level}
Initially, we discussed a probability distribution where half of the nodes that have level $i$ pointers also have level $i+1$ pointers. To get away from magic constants, we say that a fraction $p$ of the nodes with level $i$ pointers also have level $i+1$ pointers. Levels are generated randomly by an algorithm, without reeference to the number of elements in the list.
\begin{algorithm}[htb]
\caption{RandomLevel()}	
\begin{algorithmic}[1]
	 \Require
	 \Ensure
	 \State newLevel:=1
	 \State --random()returns a random value in [0, 1)
	 \While {random() $<$ p}
	 \State newLevel:=newLevel + 1
	 \EndWhile
	 \State \Return min(newLevel, MaxLevel)
\end{algorithmic}
\end{algorithm}
\subsubsection{Insert Value}

\begin{algorithm}[htb]
\caption{Insert(list, searchKey, newValue)}	
\begin{algorithmic}[1]
	 \Require
	 \Ensure
	 \State \textbf{local} update[1...MaxLevel]
	 \For { i:=list$\rightarrow$level \textbf{downto} 1} 
	 \While {x$\rightarrow$forward[i]$\rightarrow$key $<$ searchKey}
	 \State x:=x$\rightarrow$forward[i]
	 \State --x$\rightarrow$key $<$ searchKey $\leq$ x$\rightarrow$forward[1]$\rightarrow$key
	 \EndWhile
	 \State update[i]:=x
	 \EndFor
	 \State x:=x$\rightarrow$forward[1]
	 \If { x$\rightarrow$key = searchKey }
	 \State x$\rightarrow$value:=newValue
	 \Else
	 \State newLevel:=RandomLevel()
	 \If {newLevel $>$ list$\rightarrow$level }
	 \For {i:=list$\rightarrow$level+1 \textbf{to} newLevel}
	 \State update[i]:=list$\rightarrow$header
	 \EndFor
	 \State list$\rightarrow$level:=newLevel
	 \EndIf
	 \State x:=makeNode(newLevel, searchKey, value)
	 \For {i:=1 \textbf{to} newLevel}
	 \State x$\rightarrow$forward[i]:=update[i]$\rightarrow$forward[i]
	 \State update[i]$\rightarrow$forward[i]:=x
	 \EndFor
	 \EndIf
\end{algorithmic}
\end{algorithm}

\subsection{Delete}

\begin{algorithm}
\caption{Delete(list, searchKey, newValue)}	
\begin{algorithmic}[1]
	 \Require
	 \Ensure
	 \State \textbf{local} update[1...MaxLevel]
	 \State x:=list$\rightarrow$header
	 \For { i:=list$\rightarrow$level \textbf{downto} 1} 
	 \While {x$\rightarrow$forward[i]$\rightarrow$key $<$ searchKey}
	 \State x:=x$\rightarrow$forward[i]
	 \EndWhile
	 \State update[i]:=x
	 \EndFor
	 \State x:=x$\rightarrow$forward[1]
	 \If { x$\rightarrow$key = searchKey }
	 \For {i:=1 \textbf{to} list$\rightarrow$level}
	 \If{update[i]$\rightarrow$forward[i] $\neq$ x}
	 \State \textbf{break}
	 \EndIf
	 \State update[i]$\rightarrow$forward[i]:=x$\rightarrow$forward[i]
	 \EndFor
	 \State free(x)
	 \While {list$\rightarrow$level $>$ 1 \textbf{and} list$\rightarrow$header$\rightarrow$forward[list$\rightarrow$level] = NIL}
	 \State list$\rightarrow$level:=list$\rightarrow$level-1
	 \EndWhile
	 \EndIf
\end{algorithmic}
\end{algorithm}

\section{Main Function}



\chapter{Design of Experiment}\label{chapt:doe}
[\textit{Describe the process used to meet the project goal.}]

\chapter{Computational model}\label{chapt:model}
[\textit{Describe thoroughly the computational model/s used in the project}]
\section{Problem geometry and setup}
\section{Mesh generation and description}
\section{Numerical schemes}

\chapter{Complexity Analysis}
\section{The Total Result}
We give the results of the complexity analysis without proof, and then we will give our analysis.

As we can see, 
\begin{table}[h]
\centering
\begin{tabular}{ccc}
\textbf{Algorithm} & \textbf{Average} & \textbf{Worst Case} \\
\hline
Space & $O(n)$ & $O(n\log n)$ \\
\hline
Search & $O(\log n)$ & $O(n)$\\
\hline
Insert & $O(\log n)$ & $O(n)$ \\ 
\hline
Delete & $O(\log n)$ & $O(n)$ \\
\hline
\end{tabular}
\caption{The Result}
\end{table}
\section{Related Definitinos}
In order to better analyze the complexity through mathematical means, we will introduce some related concepts in advance, which will help us simplify the analysis
\subsection{$C_m^n$}
\section{Space Complexcity}
Every time a number is inserted, the program will randomly assign a height for node to storage pointer (less than MaxHeight), so it’s Space Complexity is $O(n)$
\section{Average Time Complexity}
\subsubsection{Definitions}
The height of the PSL is expected to be about $log_{\frac{1}{P}}N$. Since, among all elements that made it to a certain level, about every (1/P)th element will make it to the next higher level, one should expect to make 1/p key comparisons per level. Therefore, one should expect about 1/p*log1/p n key comparisons in total, when searching for +∞. As it will turn out (Theorem 3.3), this is exactly the leading term in the search cost for +∞ in a PSL of n keys.
\chapter{Conclusions}

\pagebreak


% Adding a bibliography if citations are used in the report
\bibliographystyle{plain}
\bibliography{bibliography.bib}
% Adds reference to the Bibliography in the ToC
\addcontentsline{toc}{chapter}{\bibname}

\pagebreak

\chapter*{Appendix A: Resources}
[\textit{Report the config files of the software used (i.e. SU2 \cite{economon2015su2} and the mesher). Also attach to this report an archive with the mesh files, solutions and the reference solution data (e.g. data points of a Cp plot ...)}]
\section*{Mesh configuration files}
\section*{SU2 configuration files}
% \section{Reference solution data}


\end{document}
